В этом уроке мы научимся как определять псевдонимы типов в С++ и узнаем для чего это может быть полезным.

Представьте что мы пишем программу, которая рассчитывает расстояние пройденное автомобилем за какое-то время и мы бы могли написать ее так:

```cpp
int main() {
  int speed_in_kilometers { 60 };
  int travel_time { 2 };
  int distance { speed_in_kilometers * travel_time };
}
```

Но возможность определения псевдонимов может сделать наш код более выразительным, синтаксис определения псевдонимов таков `typedef <тип> <псевдоним>`:

```cpp
int main() {
  typedef int kilometers_per_hour_t; // определяем kilometers_per_hour_t как псевдоним типа int 
  typedef int hour_t;
  kilometers_per_hour_t speed { 60 };
  hour_t travel_time { 2 };
}
```

Названия типов стали длиннее, но более понятыми. Мы видим, что скорость измеряется в километрах в час, а время в часах. Обратите внимание, что хорошей практикой является у псевдонима определять суффикс `_t`. Это помогает указать, что идентификатор представляет собой тип, а не переменную или функцию, а также помогает предотвратить конфликты имен с другими типами идентификаторов.

Когда еще нам могут понадобиться псевдонимы? Например, для определения псевдонимов сложных типов. Далее в курсе мы будем иметь дело с такими типами данных, как вектор и пара. Их определение довольно громоздко:

```cpp
#include <vector> // для std::vector
#include <utility> // для std::pair

int main() {
  std::vector<std::pair<int, double> > pair_list;
}
```

Ввод `std::vector<std::pair<int, double> >` везде, где вам нужно использовать этот тип, может оказаться громоздким. Гораздо проще использовать псевдоним типа:

```cpp
typedef std::vector<std::pair<int, double> > pair_list_t;
int main() {
  pair_list_t pair_list;
}
```

Так же есть альтернативный новый синтаксис определения псевдонимов с помощью ключевого слова `using` который пришел в С++ с 11 стандартом:

```cpp
using kilometers_per_hour_t = int;
```

В соответствии со стандартами кодирования предпочтительнее определять псевдоним через `using` чем через `typedef`. Так же `typedef` имеет ограничение, он не работает с шаблонами.

Так же следует учитывать, что `typedef` и `using` не определяет новый тип. Скорее, он просто создает новый идентификатор (псевдоним) для существующего типа.
